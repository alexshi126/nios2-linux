patch by Marc Hoffman to use fixed point math on Blackfin processors

--- faad2-2.0/libfaad/common.h
+++ faad2-2.0/libfaad/common.h
@@ -57,6 +57,9 @@
 #define FIXED_POINT
 #endif
 
+#ifdef __BFIN__
+#define FIXED_POINT
+#endif
 
 #define ERROR_RESILIENCE
 
--- faad2-2.0/libfaad/fixed.h
+++ faad2-2.0/libfaad/fixed.h
@@ -168,8 +168,26 @@
   #define MUL_C(A,B) (real_t)(((int64_t)(A)*(int64_t)(B)+(1 << (COEF_BITS-1))) >> COEF_BITS)
   /* multiply with fractional shift */
 #ifndef _WIN32_WCE
+#ifdef __BFIN__
+#define _MulHigh(X,Y) ({ int __xxo;                      \
+     asm (                                               \
+         "a1 = %2.H * %1.L (IS,M);\n\t"                  \
+         "a0 = %1.H * %2.H, a1+= %1.H * %2.L (IS,M);\n\t"\
+         "a1 = a1 >>> 16;\n\t"                           \
+         "%0 = (a0 += a1);\n\t"                          \
+         : "=d" (__xxo) : "d" (X), "d" (Y) : "A0","A1"); __xxo; })
+
+#define MUL_F(X,Y) ({ int __xxo;                         \
+     asm (                                               \
+         "a1 = %2.H * %1.L (M);\n\t"                     \
+         "a0 = %1.H * %2.H, a1+= %1.H * %2.L (M);\n\t"   \
+         "a1 = a1 >>> 16;\n\t"                           \
+         "%0 = (a0 += a1);\n\t"                          \
+         : "=d" (__xxo) : "d" (X), "d" (Y) : "A0","A1"); __xxo; })
+#else
   #define _MulHigh(A,B) (real_t)(((int64_t)(A)*(int64_t)(B)+(1 << (FRAC_SIZE-1))) >> FRAC_SIZE)
   #define MUL_F(A,B) (real_t)(((int64_t)(A)*(int64_t)(B)+(1 << (FRAC_BITS-1))) >> FRAC_BITS)
+#endif
 #else
   /* eVC for PocketPC has an intrinsic function that returns only the high 32 bits of a 32x32 bit multiply */
   static INLINE real_t MUL_F(real_t A, real_t B)
